;; This library is distributed in  the hope that it will be useful but without
;; any  warranty; without  even  the  implied  warranty of  merchantability or
;; fitness for a particular purpose.
;; The use and distribution terms for this software are covered by the Eclipse
;; Public License 1.0  (http://opensource.org/licenses/eclipse-1.0.php)  which
;; can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any  fashion, you are agreeing to be bound by the
;; terms of this license. You  must not remove this notice, or any other, from
;; this software.
;; Copyright (c) 2013-2014 Cherimoia, LLC. All rights reserved.

(ns ^{ :doc ""
       :author "kenl" }

  cmzlabsclj.nucleus.netty.auxdecode

  (:require [clojure.tools.logging :as log :only [info warn error debug] ])
  (:require [clojure.string :as cstr])
  (:import (org.apache.commons.io IOUtils )
           [com.zotohlabs.frwk.netty NettyFW])
  (:import (java.io ByteArrayOutputStream IOException File OutputStream ))
  (:import (java.util Map$Entry))
  (:import ( com.zotohlabs.frwk.net ULFormItems ULFileItem))
  (:import (io.netty.util AttributeKey Attribute))
  (:import (io.netty.buffer CompositeByteBuf ByteBuf Unpooled))
  (:import (io.netty.handler.codec.http.multipart DefaultHttpDataFactory DiskFileUpload
                                                  FileUpload HttpPostRequestDecoder
                                                  HttpPostRequestDecoder$EndOfDataDecoderException
                                                  InterfaceHttpData InterfaceHttpData$HttpDataType))
  (:import (io.netty.handler.stream ChunkedWriteHandler ChunkedStream))
  (:import (io.netty.channel ChannelHandlerContext Channel
                             ChannelFutureListener ChannelFuture
                             ChannelPipeline ChannelHandler))
  (:import (io.netty.handler.codec.http HttpHeaders HttpVersion HttpContent LastHttpContent
                                        HttpHeaders$Values HttpHeaders$Names
                                        HttpMessage HttpRequest HttpResponse HttpResponseStatus
                                        DefaultFullHttpResponse DefaultHttpResponse QueryStringDecoder
                                        HttpMethod HttpObject
                                        DefaultHttpRequest HttpServerCodec HttpClientCodec
                                        HttpResponseEncoder))
  (:import (io.netty.handler.ssl SslHandler))
  (:import (io.netty.handler.codec.http.websocketx WebSocketFrame WebSocketServerHandshaker
                                                   WebSocketServerHandshakerFactory ContinuationWebSocketFrame
                                                   CloseWebSocketFrame BinaryWebSocketFrame TextWebSocketFrame
                                                   PingWebSocketFrame PongWebSocketFrame))
  (:import (com.zotohlabs.frwk.netty NettyFW))
  (:import (com.zotohlabs.frwk.io XData))
  (:use [cmzlabsclj.nucleus.util.core :only [ notnil? Try! TryC] ])
  (:use [cmzlabsclj.nucleus.util.str :only [strim nsb hgl?] ])
  (:use [cmzlabsclj.nucleus.netty.comms])
  (:use [cmzlabsclj.nucleus.util.io :only [NewlyTmpfile MakeBitOS] ]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def ^:private FORMDEC-KEY (AttributeKey. "formdecoder"))
(def ^:private FORMITMS-KEY (AttributeKey. "formitems"))
(def ^:private XDATA-KEY (AttributeKey. "xdata"))
(def ^:private XOS-KEY (AttributeKey. "ostream"))
(def ^:private MSGINFO-KEY (AttributeKey. "msginfo"))
(def ^:private CBUF-KEY (AttributeKey. "cbuffer"))
(def ^:private WSHSK-KEY (AttributeKey. "wsockhandshaker"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- delAttr ""

  [^ChannelHandlerContext ctx ^AttributeKey akey]

  (-> (.attr ctx akey)(.remove)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- slurpByteBuf ""

  [^ByteBuf buf ^OutputStream os]

  (let [ len (.readableBytes buf) ]
    (.readBytes buf os len)
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- setAttr ""

  [^ChannelHandlerContext ctx ^AttributeKey akey aval]

  (-> (.attr ctx akey)(.set aval)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- getAttr ""

  [^ChannelHandlerContext ctx ^AttributeKey akey]

  (-> (.attr ctx akey)(.get)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- resetAttrs ""

  [^ChannelHandlerContext ctx]

  (let [ ^HttpPostRequestDecoder dc (getAttr ctx FORMDEC-KEY)
         ^ULFormItems fis (getAttr ctx FORMITMS-KEY)
         ^ByteBuf buf (getAttr ctx CBUF-KEY) ]
    (delAttr ctx FORMITMS-KEY)
    (delAttr ctx MSGINFO-KEY)
    (delAttr ctx FORMDEC-KEY)
    (delAttr ctx CBUF-KEY)
    (delAttr ctx XDATA-KEY)
    (delAttr ctx XOS-KEY)
    (delAttr ctx WSHSK-KEY)
    (when-not (nil? buf) (.release buf))
    (when-not (nil? dc) (.destroy dc))
    (when-not (nil? fis) (.destroy fis))
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- isFormPost ""

  ;; boolean
  [^HttpRequest req ^String method]

  (let [ ct (cstr/lower-case (nsb (HttpHeaders/getHeader req "content-type"))) ]
    ;; multipart form
    (and (or (= "POST" method) (= "PUT" method) (= "PATCH" method))
         (or (>= (.indexOf ct "multipart/form-data") 0)
             (>= (.indexOf ct "application/x-www-form-urlencoded") 0)))
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- extractHeaders ""

  ;; map
  [^HttpHeaders hdrs]

  (let []
    (persistent! (reduce (fn [sum ^String n]
                           (assoc! sum (cstr/lower-case n) (vec (.getAll hdrs n))))
                       (transient {})
                       (.names hdrs)))
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- extractParams ""

  ;; map
  [^QueryStringDecoder decr]

  (let []
    (persistent! (reduce (fn [sum ^Map$Entry en]
                           (assoc! sum (nsb (.getKey en)) (vec (.getValue en))))
                         (transient {})
                         (.parameters decr)))
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- extractMsgInfo ""

  ;; map
  [^HttpMessage msg]

  (with-local-vars [ m { :host (strim (HttpHeaders/getHeader msg "Host" ""))
                         :protocol (strim (.getProtocolVersion msg))
                         :keep-alive (HttpHeaders/isKeepAlive msg)
                         :clen (HttpHeaders/getContentLength msg 0)
                         :uri ""
                         :status ""
                         :code 0
                         :formpost false
                         :wsock false
                         :params {}
                         :method ""
                         :is-chunked (HttpHeaders/isTransferEncodingChunked msg)
                         :headers (extractHeaders (.headers msg))  } ]
    (when (instance? HttpResponse msg)
      (let [ s (.getStatus ^HttpResponse msg)
             r (.reasonPhrase s)
             c (.code s) ]
        (var-set m (merge @m { :code c :status r } ))))
    (when (instance? HttpRequest msg)
      (let [ ws (cstr/lower-case (strim (HttpHeaders/getHeader msg "upgrade")))
             mo (strim (HttpHeaders/getHeader msg "X-HTTP-Method-Override"))
             ^HttpRequest req msg
             md (-> req (.getMethod) (.name))
             mt (cstr/upper-case (if mo mo md))
             form (isFormPost msg mt)
             wsock (and (= "GET" mt) (= "websocket" ws))
             dc (QueryStringDecoder. (.getUri req))
             pms (extractParams dc)
             uri (.path dc) ]
        (var-set m (merge @m { :uri uri :formpost form :wsock wsock :params pms :method mt }))))
    @m
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(declare handleFormPostChunk)
(defn- handleFormPost ""

  [^ChannelHandlerContext ctx ^HttpRequest req]

  (let [ fac (DefaultHttpDataFactory. (com.zotohlabs.frwk.io.IOUtils/streamLimit))
         dc (HttpPostRequestDecoder. fac req) ]
    (setAttr ctx FORMITMS-KEY (ULFormItems.))
    (setAttr ctx FORMDEC-KEY dc)
    (handleFormPostChunk ctx req)
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- writeHttpData ""

  [^ChannelHandlerContext ctx ^InterfaceHttpData data]

  (when-not (nil? data)
    (let [ ^String nm (-> (.getHttpDataType data)(.name))
           ^ULFormItems fis (getAttr ctx FORMITMS-KEY) ]
      (cond
        (= (.getHttpDataType data) (InterfaceHttpData$HttpDataType/Attribute))
        (let [ ^io.netty.handler.codec.http.multipart.Attribute attr data
               baos (MakeBitOS) ]
          (slurpByteBuf (.content attr) baos)
          (.add fis (ULFileItem. nm (.toByteArray baos))))

        (= (.getHttpDataType data) (InterfaceHttpData$HttpDataType/FileUpload))
        (let [ ^FileUpload fu data
               ct (.getContentType fu)
               fnm (.getFilename fu) ]
          (when (.isCompleted fu)
            (cond
              (instance? DiskFileUpload fu)
              (let [ fp (NewlyTmpfile false) ]
                (.renameTo ^DiskFileUpload fu fp)
                (.add fis (ULFileItem. nm  ct fnm (XData. fp))))

              :else
              (let [ [ ^File fp ^OutputStream os ] (NewlyTmpfile true)
                     buf (.content fu) ]
                (slurpByteBuf buf os)
                (IOUtils/closeQuietly os)
                (.add fis (ULFileItem. nm  ct fnm (XData. fp))))
            )))

        :else (throw (IOException. "Bad POST: unknown http data.")))
    )))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- readHttpDataChunkByChunk ""

  [^ChannelHandlerContext ctx ^HttpPostRequestDecoder dc]

  (try
    (while (.hasNext dc)
      (when-let [ data (.next dc) ]
        (try
          (writeHttpData ctx data)
          (finally
            (.release ^InterfaceHttpData data)))))
    (catch HttpPostRequestDecoder$EndOfDataDecoderException e#) ;; eat it => indicates end of content chunk by chunk
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- handleFormPostChunk ""

  [^ChannelHandlerContext ctx msg]

  (with-local-vars [ ^HttpPostRequestDecoder dc (getAttr ctx FORMDEC-KEY)
                     err nil ]
    (when (instance? HttpContent msg)
      (try
        (.offer ^HttpPostRequestDecoder @dc  ^HttpContent msg)
        (readHttpDataChunkByChunk ctx @dc)
        (catch  Throwable e#
          (var-set err e#)
          (.fireExceptionCaught ctx e#))))
    (when (and (nil? @err) (instance? LastHttpContent msg))
      (let [ info (getAttr ctx MSGINFO-KEY)
             fis (getAttr ctx FORMITMS-KEY)
             ^XData xs (getAttr ctx XDATA-KEY) ]
        (delAttr ctx FORMITMS-KEY)
        (.resetContent xs fis)
        (resetAttrs ctx)
        (.fireChannelRead ctx { :info info :payload xs } )))
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- tooMuchData? ""

  ;; boolean
  [^ByteBuf content chunc]

  (let [ buf (cond
               (instance? WebSocketFrame chunc) (.content ^WebSocketFrame chunc)
               (instance? HttpContent chunc) (.content ^HttpContent chunc)
               :else nil) ]
    (if (notnil? buf)
      (> (.readableBytes content)
         (- (com.zotohlabs.frwk.io.IOUtils/streamLimit)
            (.readableBytes buf)))
      false)
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- switchBufToFile ""

  ^OutputStream
  [^ChannelHandlerContext ctx ^CompositeByteBuf bbuf]

  (let [ [^File fp ^OutputStream os] (NewlyTmpfile true)
         ^XData xs (getAttr ctx XDATA-KEY) ]
    (slurpByteBuf bbuf os)
    (.flush os)
    (.resetContent xs fp)
    (setAttr ctx XOS-KEY os)
    os
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- flushToFile ""

  [^OutputStream os chunc]

  (let [ buf (cond
               (instance? WebSocketFrame chunc) (.content ^WebSocketFrame chunc)
               (instance? HttpContent chunc) (.content ^HttpContent chunc)
               :else nil) ]
    (when-not (nil? buf)
      (slurpByteBuf buf os)
      (.flush os))
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- addMoreHeaders  ""

  [^ChannelHandlerContext ctx ^HttpHeaders hds]

  (let [ info (getAttr ctx MSGINFO-KEY)
         old (:headers info) ]
    (setAttr ctx MSGINFO-KEY (assoc info
                                    :headers
                                    (merge old (extractHeaders hds))))
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- maybeFinzMsgChunk

  [^ChannelHandlerContext ctx msg]

  (let [ ^OutputStream os (getAttr ctx XOS-KEY)
         ^ByteBuf cbuf (getAttr ctx CBUF-KEY)
         ^XData xs (getAttr ctx XDATA-KEY)
         info (getAttr ctx MSGINFO-KEY) ]
    (when (instance? LastHttpContent msg)
      (addMoreHeaders ctx (.trailingHeaders ^LastHttpContent msg))
      (if (nil? os)
        (let [ baos (MakeBitOS) ]
          (slurpByteBuf cbuf baos)
          (.resetContent xs baos))
        (do (IOUtils/closeQuietly os)))
      (let [ olen (:clen info)
             clen (.size xs) ]
        (when-not (= olen clen)
          (log/warn "content-length read from headers = " olen ", new clen = " clen )
          (setAttr ctx MSGINFO-KEY (merge info { :clen clen }))))
      (let [ info (getAttr ctx MSGINFO-KEY) ]
        (resetAttrs ctx)
        (.fireChannelRead ctx { :info info :payload xs })))
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- handleMsgChunk ""

  [^ChannelHandlerContext ctx msg]

  (let [ ^CompositeByteBuf cbuf (getAttr ctx CBUF-KEY)
         ^XData xs (getAttr ctx XDATA-KEY) ]
    (when (instance? HttpContent msg)
      (let [ ^OutputStream os (if (and (not (.hasContent xs)) (tooMuchData? cbuf msg))
                                  (switchBufToFile ctx cbuf)
                                  (getAttr ctx XOS-KEY))
             ^HttpContent chk msg ]
        (when (-> (.content chk)(.isReadable))
          (if (nil? os)
            (do
              (.retain chk)
              (.addComponent cbuf (.content chk))
              (.writerIndex cbuf (+ (.writerIndex cbuf)
                                   (-> (.content chk)(.readableBytes)))))
            (flushToFile os chk))))
      (maybeFinzMsgChunk ctx msg))
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- handleRedirect ""

  [^ChannelHandlerContext ctx ^HttpMessage msg]

  (let [ err (IOException. "Redirect is not supported at this time.") ]
    (log/error err "")
    (.fireExceptionCaught ctx err)
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- handleInboundMsg ""

  [^ChannelHandlerContext ctx ^HttpMessage msg]

  (with-local-vars [ info (getAttr ctx MSGINFO-KEY) good true ]
    (setAttr ctx CBUF-KEY (Unpooled/compositeBuffer 1024))
    (setAttr ctx XDATA-KEY (XData.))
    (when (instance? HttpResponse msg)
      (let [ c (:code @info) ]
        (cond
          (and (>= c 200) (< c 300))
          nil

          (and (>= c 300) (< c 400))
          (do
            (var-set good false)
            (handleRedirect ctx msg))

          :else (log/warn "received http-response with error code " c))))
    (when @good
      (handleMsgChunk ctx msg))
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- maybeSSL ""

  [^ChannelHandlerContext ctx]

  (notnil? (-> (NettyFW/getPipeline ctx)
               (.get (class SslHandler)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- wsSSL ""

  [^ChannelHandlerContext ctx]

  (let [ ^SslHandler ssl (-> (NettyFW/getPipeline ctx)
                             (.get (class SslHandler)))
         ch (.channel ctx) ]
    (when-not (nil? ssl)
      (-> (.handshakeFuture ssl)
          (.addListener (reify ChannelFutureListener
                          (operationComplete [_ f]
                            (when-not (.isSuccess f)
                              (NettyFW/closeChannel ch)) )))))
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- handleWSock ""

  [^ChannelHandlerContext ctx ^HttpRequest req]

  (let [ prx (if (maybeSSL ctx) "wss://" "ws://")
         info (getAttr ctx MSGINFO-KEY)
         us (str prx (:host info) (.getUri req))
         wf (WebSocketServerHandshakerFactory. us nil false)
         hs (.newHandshaker wf req)
         ch (.channel ctx) ]
    (if (nil? hs)
      (do
        (WebSocketServerHandshakerFactory/sendUnsupportedVersionResponse ch)
        (Try! (NettyFW/closeChannel ch)))
      (do
        (setAttr ctx CBUF-KEY (Unpooled/compositeBuffer 1024))
        (setAttr ctx XDATA-KEY (XData.))
        (setAttr ctx WSHSK-KEY hs)
        (-> (.handshake hs ch req)
            (.addListener (reify ChannelFutureListener
                            (operationComplete [_ f]
                              (if (.isSuccess f)
                                  (wsSSL ctx)
                                  (.fireExceptionCaught ctx (.cause f)))))))))
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- readFrame  ""

  [^ChannelHandlerContext ctx ^WebSocketFrame frame]

  (let [ ^CompositeByteBuf cbuf (getAttr ctx CBUF-KEY)
         ^XData xs (getAttr ctx XDATA-KEY)
         ^OutputStream os (if (and (not (.hasContent xs)) (tooMuchData? cbuf frame))
                              (switchBufToFile ctx cbuf)
                              (getAttr ctx XOS-KEY)) ]
    (if (nil? os)
        (do
          (.retain frame)
          (.addComponent cbuf (.content frame))
          (.writerIndex cbuf (+ (.writerIndex cbuf)
                               (-> (.content frame)(.readableBytes)))))
        (flushToFile os frame))
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- maybeFinzFrame ""

  [^ChannelHandlerContext ctx ^WebSocketFrame frame]

  (when (.isFinalFragment frame)
    (let  [ ^CompositeByteBuf cbuf (getAttr ctx CBUF-KEY)
            ^OutputStream os (getAttr ctx XOS-KEY)
            ^XData xs (getAttr ctx XDATA-KEY) ]
      (when-not (nil? os)
        (do (.close os))
        (let [ baos (MakeBitOS) ]
          (slurpByteBuf cbuf baos)
          (.resetContent xs baos)))
      (let [ info (getAttr ctx MSGINFO-KEY) ]
        (resetAttrs ctx)
        (.fireChannelRead ctx { :info info :payload xs }))
    )))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- handleWSockFrame  ""

  [^ChannelHandlerContext ctx ^WebSocketFrame frame]

  (let [ ^WebSocketServerHandshaker hs (getAttr ctx WSHSK-KEY)
         ch (.channel ctx) ]
    (log/debug "nio-wsframe: received a " (type frame))
    (cond
      (instance? CloseWebSocketFrame frame)
      (do
        (resetAttrs ctx)
        (.close hs ch ^CloseWebSocketFrame frame)
        (Try! (NettyFW/closeChannel ch)))

      (instance? PingWebSocketFrame frame)
      (.write ch (PongWebSocketFrame. (.content frame)))

      (or (instance? ContinuationWebSocketFrame frame)
          (instance? TextWebSocketFrame frame)
          (instance? BinaryWebSocketFrame frame))
      (do
        (readFrame ctx frame)
        (maybeFinzFrame ctx frame))

      :else (throw (IOException. "Bad wsock: unknown frame.")))
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- auxReqHandler ""

  [^ChannelHandlerContext ctx msg options]

  (let []
    (cond
      (or (instance? HttpResponse msg)
          (instance? HttpRequest msg))
      (let [ info (extractMsgInfo msg) ]
        (setAttr ctx MSGINFO-KEY info)
        (cond
          (:formpost info)
          (handleFormPost ctx msg)

          (:wsock info)
          (handleWSock ctx msg)

          :else
          (handleInboundMsg ctx msg)))

      (instance? HttpContent msg)
      (let [ info (getAttr ctx MSGINFO-KEY) ]
        (if (:formpost info)
          (handleFormPostChunk ctx msg)
          (handleMsgChunk ctx msg)))

      (instance? WebSocketFrame msg)
      (handleWSockFrame ctx msg)

      :else (throw (IOException. (str "Bad message: unknown http object: " (type msg)))) )
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn AuxDecoder

  ^ChannelHandler
  [options]

  (NettyInboundHandler auxReqHandler options))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn AddAuxDecoder ""

  ^ChannelPipeline
  [pipe options]

  (let []
    (.addLast ^ChannelPipeline pipe "auxdecode" (AuxDecoder options))
    pipe
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def ^:private auxdecode-eof nil)

;; This library is distributed in  the hope that it will be useful but without
;; any  warranty; without  even  the  implied  warranty of  merchantability or
;; fitness for a particular purpose.
;; The use and distribution terms for this software are covered by the Eclipse
;; Public License 1.0  (http://opensource.org/licenses/eclipse-1.0.php)  which
;; can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any  fashion, you are agreeing to be bound by the
;; terms of this license. You  must not remove this notice, or any other, from
;; this software.
;; Copyright (c) 2013-2014 Cherimoia, LLC. All rights reserved.

(ns ^{ :doc ""
       :author "kenl" }

  cmzlabsclj.nucleus.netty.client

  (:require [clojure.tools.logging :as log :only [info warn error debug] ])
  (:require [clojure.string :as cstr])
  (:import [java.net URL URI InetSocketAddress]
           [com.zotohlabs.frwk.netty NettyFW])
  (:import [java.io IOException])
  (:import (io.netty.buffer Unpooled))
  (:import (io.netty.channel.nio NioEventLoopGroup))
  (:import (io.netty.bootstrap Bootstrap))
  (:import (io.netty.handler.stream ChunkedStream))
  (:import (io.netty.channel ChannelHandlerContext Channel ChannelOption
                             ChannelFutureListener ChannelFuture
                             ChannelPipeline ChannelHandler ))
  (:import (io.netty.handler.codec.http HttpMessage HttpResponseStatus
                                        HttpMethod
                                        HttpHeaders HttpVersion
                                        DefaultHttpRequest))
  (:import (com.zotohlabs.frwk.netty NettyFW))
  (:import (com.zotohlabs.frwk.io XData))
  (:use [cmzlabsclj.nucleus.netty.comms])
  (:use [cmzlabsclj.nucleus.util.core :only [notnil? Try! TryC] ])
  (:use [cmzlabsclj.nucleus.util.str :only [strim nsb hgl?] ]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;(set! *warn-on-reflection* false)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn BootstrapNettyClient

  ;; map
  [initor options]

  (let [ g (NioEventLoopGroup.)
         bs (doto (Bootstrap.)
                  (.group g)
                  (.channel io.netty.channel.socket.nio.NioSocketChannel)
                  (.option ChannelOption/TCP_NODELAY true)
                  (.option ChannelOption/SO_KEEPALIVE true))
         opts (:netty options) ]
    (doseq [ [k v] (seq opts) ]
      (.option bs k v))
    (.handler bs (initor options))
    { :bootstrap bs }
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn ConnectNettyClient "Start Netty 4.x client."

  [^URL targetUrl netty]

  (let [ ssl (= "https" (.getProtocol targetUrl))
         pnum (.getPort targetUrl)
         port (if (< pnum 0) (if ssl 443 80) pnum)
         host (.getHost targetUrl)
         sock (InetSocketAddress. host (int port))
         ^Bootstrap boot (:bootstrap netty)
         ^ChannelFuture cf (-> boot
                               (.connect sock)
                               (.sync)) ]
    (when-not (.isSuccess cf)
      (throw (if-let [ eee (.cause cf) ]
                     eee
                     (IOException. (str "Connect failed: " targetUrl)))))
    (merge netty { :channel (.channel cf) })
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn- sendHttpClient ""

  [netty ^String verb ^XData xdata options]

  (let [ clen (if (nil? xdata) 0 (.size xdata))
         ^URL targetUrl (:targetUrl options)
         ^Channel ch (:channel netty)
         mo (:override options)
         md (if (> clen 0)
              (if (hgl? mo) "POST")
              (if (hgl? mo) mo "GET"))
         mt (if-let [mo mo] mo md)
         req (DefaultHttpRequest. HttpVersion/HTTP_1_1
                                  (HttpMethod/valueOf mt)
                                  (nsb targetUrl))
         presend (:presend options) ]

    (HttpHeaders/setHeader req "Connection" (if (:keep-alive options) "keep-alive" "close"))
    (HttpHeaders/setHeader req "host" (.getHost targetUrl))
    (when (fn? presend) (presend ch req))

    (let [ ct (HttpHeaders/getHeader req "content-type") ]
      (when (and (cstr/blank? ct)
                 (> clen 0))
        (HttpHeaders/setHeader req "content-type" "application/octet-stream")))

    (HttpHeaders/setContentLength req clen)
    (log/debug "Netty client: about to flush out request (headers)")
    (log/debug "Netty client: content has length " clen)
    (with-local-vars [wf nil]
      (var-set wf (WWrite ch req))
      (if (> clen 0)
        (var-set wf (if (> clen (com.zotohlabs.frwk.io.IOUtils/streamLimit))
                      (WFlush ch (ChunkedStream. (.stream xdata)))
                      (WFlush ch (Unpooled/wrappedBuffer (.javaBytes xdata)))))
        (NettyFW/flush ch))
      (CloseCF @wf (:keep-alive options) ))
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Async HTTP Post
(defn AsyncPost "Async HTTP Post"

  ([ netty ^XData xdata options ]
   (sendHttpClient "POST" netty xdata options))

  ([ netty ^XData xdata ]
   (AsyncPost netty xdata {})) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Async HTTP Get
(defn AsyncGet "Async HTTP GET"

  ([ netty ] (AsyncGet netty {}))

  ([ netty options ]
   (sendHttpClient "GET" netty nil options)) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def ^:private client-eof nil)

;; This library is distributed in  the hope that it will be useful but without
;; any  warranty; without  even  the  implied  warranty of  merchantability or
;; fitness for a particular purpose.
;; The use and distribution terms for this software are covered by the Eclipse
;; Public License 1.0  (http://opensource.org/licenses/eclipse-1.0.php)  which
;; can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any  fashion, you are agreeing to be bound by the
;; terms of this license. You  must not remove this notice, or any other, from
;; this software.
;; Copyright (c) 2013-2014 Cherimoia, LLC. All rights reserved.

(ns ^{ :doc ""
       :author "kenl" }

  cmzlabsclj.nucleus.netty.comms

  (:require [clojure.tools.logging :as log :only [info warn error debug] ])
  (:require [clojure.string :as cstr])
  (:import (java.lang.reflect Field)
           [com.zotohlabs.frwk.netty NettyFW])
  (:import (java.io IOException ByteArrayOutputStream File OutputStream InputStream))
  (:import (java.util HashMap Properties ArrayList))
  (:import (java.net URI URL InetSocketAddress))
  (:import (org.apache.commons.io IOUtils))
  (:import (org.apache.commons.lang3 StringUtils))
  (:import (java.nio.charset Charset))
  (:import (io.netty.channel.socket SocketChannel))
  (:import (io.netty.channel ChannelHandlerContext Channel
                             ChannelInboundHandlerAdapter
                             SimpleChannelInboundHandler
                             ChannelInitializer ChannelFuture
                             ChannelFutureListener
                             ChannelPipeline ChannelHandler))
  (:import (io.netty.handler.codec.http DefaultHttpResponse HttpResponseStatus
                                        DefaultFullHttpResponse HttpServerCodec
                                        HttpResponse
                                        HttpHeaders HttpVersion))
  (:import (io.netty.handler.stream ChunkedWriteHandler))
  (:import (io.netty.handler.ssl SslHandler))
  (:import (io.netty.buffer ByteBuf))
  (:import (com.zotohlabs.frwk.netty NettyFW))
  (:use [cmzlabsclj.nucleus.util.core :only [notnil? Try! TryC] ])
  (:use [cmzlabsclj.nucleus.util.str :only [strim nsb hgl?] ]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;(set! *warn-on-reflection* false)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; map of { int (code) -> HttpResponseStatus }
(def HTTP-CODES
  (let [ to-key (fn [^Field f] (.code ^HttpResponseStatus (.get f nil)))
         fields (:fields (bean HttpResponseStatus))
         kkeys (map to-key fields)
         vvals (map (fn [^Field f] (.get f nil)) fields) ]
    (into {} (map vec (partition 2 (interleave kkeys vvals))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn NettyInboundAdaptor ""

  ^ChannelHandler
  [handler options]

  (let []
    (proxy [ChannelInboundHandlerAdapter][]
      (channelRead [c msg]
        (handler c msg options)))
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn NettyInboundHandler ""

  ^ChannelHandler
  [handler options]

  (let []
    (proxy [SimpleChannelInboundHandler][]
      (channelRead0 [c msg]
        (handler c msg options)))
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn NettyChannelInitor ""

  [wrapper options]

  (let []
    (proxy [ChannelInitializer] []
      (initChannel [^SocketChannel ch]
        (let [ ^ChannelPipeline pl (NettyFW/getPipeline ch) ]
          (apply wrapper pl options))))
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn CloseCF "Maybe close the channel."

  [^ChannelFuture cf keepAlive?]

  (when (and (not keepAlive?) (notnil? cf))
    (.addListener cf ChannelFutureListener/CLOSE)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn MakeHttpReply "Make a netty http-response object."

  (^HttpResponse [] (MakeHttpReply 200))

  (^HttpResponse [status]
    (DefaultHttpResponse. HttpVersion/HTTP_1_1
                          (get HTTP-CODES status))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn ReplyXXX ""

  ([^Channel ch status] (ReplyXXX ch status false))

  ([^Channel ch status keepAlive?]
    (let [ rsp (MakeHttpReply status) ]
      (HttpHeaders/setContentLength rsp 0)
      (-> (.write ch rsp)
          (CloseCF keepAlive?))
    )))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn WWrite "Write object but no flush."

  ^ChannelFuture
  [ch obj]

  ;; had to do this to work-around reflection warnings :(
  (NettyFW/writeOnly ^Channel ch obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn WFlush "Write object and then flush."

  ^ChannelFuture
  [ch obj]

  ;; had to do this to work-around reflection warnings :(
  (NettyFW/writeFlush ^Channel ch obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn MaybeSSL ""

  [^ChannelHandlerContext ctx]

  (notnil? (-> (NettyFW/getPipeline ctx)
               (.get (class SslHandler)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn MakeFullHttpReply "Make a netty http-response object."

  (^HttpResponse [status ^ByteBuf obj]
    (DefaultFullHttpResponse. HttpVersion/HTTP_1_1 (get HTTP-CODES status) obj))

  (^HttpResponse [] (MakeFullHttpReply 200))

  (^HttpResponse [status]
    (DefaultFullHttpResponse. HttpVersion/HTTP_1_1 (get HTTP-CODES status))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn SendRedirect "Redirect a request."

  [^Channel ch perm ^String targetUrl]

  (let [ rsp (MakeFullHttpReply (if perm 301 307)) ]
    (log/debug "redirecting to -> " targetUrl)
    (HttpHeaders/setHeader rsp  "location" targetUrl)
    (CloseCF (WFlush ch rsp) false)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn Continue100 "Send back 100-continue."

  [^ChannelHandlerContext ctx]

  (-> (.channel ctx) (WFlush (MakeFullHttpReply 100))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn AddServerCodec ""

  ^ChannelPipeline
  [^ChannelPipeline pipe]

  (let []
    (.addLast pipe "codec" (HttpServerCodec.))
    pipe
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn AddWriteChunker ""

  ^ChannelPipeline
  [^ChannelPipeline pipe]

  (let []
    (.addLast pipe "chunker" (ChunkedWriteHandler.))
    pipe
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def ^:private comms-eof nil)

;; This library is distributed in  the hope that it will be useful but without
;; any  warranty; without  even  the  implied  warranty of  merchantability or
;; fitness for a particular purpose.
;; The use and distribution terms for this software are covered by the Eclipse
;; Public License 1.0  (http://opensource.org/licenses/eclipse-1.0.php)  which
;; can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any  fashion, you are agreeing to be bound by the
;; terms of this license. You  must not remove this notice, or any other, from
;; this software.
;; Copyright (c) 2013-2014 Cherimoia, LLC. All rights reserved.

(ns ^{ :doc ""
       :author "kenl" }

  cmzlabsclj.nucleus.netty.exception

  (:require [clojure.tools.logging :as log :only [info warn error debug] ])
  (:require [clojure.string :as cstr])
  (:import (io.netty.buffer Unpooled))
  (:import (io.netty.channel ChannelHandler ChannelHandlerContext
                             ChannelFutureListener ChannelFuture
                             ChannelPipeline
                             ChannelInboundHandlerAdapter))
  (:import (io.netty.handler.codec.http HttpMessage HttpResponseStatus
                                        HttpHeaders HttpVersion
                                        DefaultFullHttpResponse))
  (:use [cmzlabsclj.nucleus.netty.comms :only [ReplyXXX] ]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;(set! *warn-on-reflection* false)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn ExceptionCatcher ""

  ^ChannelHandler
  []

  (proxy [ChannelInboundHandlerAdapter] []
    (exceptionCaught [c err]
      (let [^ChannelHandlerContext ctx c
            ch (.channel ctx) ]
        (ReplyXXX ch 500)
      ))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn AddExceptionCatcher ""

  ^ChannelPipeline
  [pipe options]

  (let []
    (.addLast ^ChannelPipeline  pipe "error-handler" (ExceptionCatcher))
    pipe
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def ^:private exception-eof nil)

;; This library is distributed in  the hope that it will be useful but without
;; any  warranty; without  even  the  implied  warranty of  merchantability or
;; fitness for a particular purpose.
;; The use and distribution terms for this software are covered by the Eclipse
;; Public License 1.0  (http://opensource.org/licenses/eclipse-1.0.php)  which
;; can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any  fashion, you are agreeing to be bound by the
;; terms of this license. You  must not remove this notice, or any other, from
;; this software.
;; Copyright (c) 2013-2014 Cherimoia, LLC. All rights reserved.

(ns ^{ :doc ""
       :author "kenl" }

  cmzlabsclj.nucleus.netty.expect100

  (:require [clojure.tools.logging :as log :only [info warn error debug] ])
  (:require [clojure.string :as cstr])
  (:import (io.netty.buffer Unpooled))
  (:import (io.netty.channel ChannelHandler ChannelHandlerContext
                             ChannelFutureListener ChannelFuture
                             ChannelPipeline
                             ChannelInboundHandlerAdapter))
  (:import (io.netty.handler.codec.http HttpMessage HttpResponseStatus
                                        HttpHeaders HttpVersion
                                        DefaultFullHttpResponse)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;(set! *warn-on-reflection* false)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def ^:private CONTINUE (DefaultFullHttpResponse. (HttpVersion/HTTP_1_1)
                                                  (HttpResponseStatus/CONTINUE)
                                                  (Unpooled/EMPTY_BUFFER)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn Expect100 ""

  ^ChannelHandler
  []

  (proxy [ChannelInboundHandlerAdapter] []
    (channelRead [c msg]
      (let [^ChannelHandlerContext ctx c]
        (when (and (instance?  HttpMessage msg)
                   (HttpHeaders/is100ContinueExpected msg))
          (-> (.writeAndFlush ctx CONTINUE)
              (.addListener (reify ChannelFutureListener
                              (operationComplete [_  f]
                                (when-not (.isSuccess ^ChannelFuture f)
                                          (.fireExceptionCaught ctx (.cause f))))))))
        (.fireChannelRead ctx msg)

      ))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn AddExpect100 ""

  ^ChannelPipeline
  [pipe options]

  (let []
    (.addLast ^ChannelPipeline  pipe "e100" (Expect100))
    pipe
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def ^:private expect100-eof nil)

;; This library is distributed in  the hope that it will be useful but without
;; any  warranty; without  even  the  implied  warranty of  merchantability or
;; fitness for a particular purpose.
;; The use and distribution terms for this software are covered by the Eclipse
;; Public License 1.0  (http://opensource.org/licenses/eclipse-1.0.php)  which
;; can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any  fashion, you are agreeing to be bound by the
;; terms of this license. You  must not remove this notice, or any other, from
;; this software.
;; Copyright (c) 2013-2014 Cherimoia, LLC. All rights reserved.


(ns ^{ :doc ""
       :author "kenl" }

  cmzlabsclj.nucleus.netty.server

  (:require [clojure.tools.logging :as log :only [info warn error debug] ])
  (:require [clojure.string :as cstr])
  (:import (java.net InetAddress InetSocketAddress))
  (:import (io.netty.channel.nio NioEventLoopGroup))
  (:import (io.netty.bootstrap ServerBootstrap))
  (:import (io.netty.channel ChannelHandlerContext Channel ChannelOption
                             ChannelFutureListener ChannelFuture
                             ChannelPipeline ChannelHandler ))
  (:import (io.netty.handler.codec.http HttpHeaders HttpVersion ))
  (:use [cmzlabsclj.nucleus.util.core :only [notnil? Try! TryC] ])
  (:use [cmzlabsclj.nucleus.netty.comms])
  (::use [cmzlabsclj.nucleus.util.str :only [strim nsb hgl? nichts?] ]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;(set! *warn-on-reflection* false)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Netty NIO Server
(defn BootstrapNetty ""

  ;; map
  [initor options]

  (let [ gp (NioEventLoopGroup.) gc (NioEventLoopGroup.)
         bs (doto (ServerBootstrap.)
                  (.group gp gc)
                  (.channel io.netty.channel.socket.nio.NioServerSocketChannel)
                  (.option ChannelOption/SO_REUSEADDR true)
                  (.option ChannelOption/SO_BACKLOG 100)
                  (.childOption ChannelOption/SO_RCVBUF (int (* 2 1024 1024)))
                  (.childOption ChannelOption/TCP_NODELAY true))
         opts (if-let [ x (:netty options) ] x {} ) ]
    (doseq [ [k v] (seq opts) ]
      (if (= :child k)
        (doseq [ [x y] (seq v) ]
          (.childOption bs x y))
        (.option bs k v)))
    (.childHandler bs (NettyChannelInitor initor options))
    { :bootstrap bs }
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; start netty on host/port
(defn StartNetty ""

  [^String host port netty]

  (let [ ^InetAddress ip (if (nichts? host)
                             (InetAddress/getLocalHost)
                             (InetAddress/getByName host))
         ^ServerBootstrap boot (:bootstrap netty)
         ch (-> boot
                (.bind (InetSocketAddress. ip (int port)))
                (.sync)
                (.channel)) ]
    (log/debug "netty-xxx-server: running on host " ip ", port " port)
    (merge netty { :channel ch })
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn StopNetty "Clean up resources used by a netty server."

  [netty]

  (let [ ^ServerBootstrap bs (:bootstrap netty)
         gc (.childGroup bs)
         gp (.group bs)
         ^Channel ch (:channel netty) ]
    (-> (.close ch)
        (.addListener (reify ChannelFutureListener
                        (operationComplete [_ cff]
                          (when-not (nil? gp) (Try! (.shutdownGracefully gp)))
                          (when-not (nil? gc) (Try! (.shutdownGracefully gc))) )) ))
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def ^:private server-eof nil)

;; This library is distributed in  the hope that it will be useful but without
;; any  warranty; without  even  the  implied  warranty of  merchantability or
;; fitness for a particular purpose.
;; The use and distribution terms for this software are covered by the Eclipse
;; Public License 1.0  (http://opensource.org/licenses/eclipse-1.0.php)  which
;; can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any  fashion, you are agreeing to be bound by the
;; terms of this license. You  must not remove this notice, or any other, from
;; this software.
;; Copyright (c) 2013-2014 Cherimoia, LLC. All rights reserved.

(ns ^{ :doc ""
       :author "kenl" }

  cmzlabsclj.nucleus.netty.ssl

  (:require [clojure.tools.logging :as log :only [info warn error debug] ])
  (:require [clojure.string :as cstr])

  (:import (javax.net.ssl SSLEngine SSLContext))
  (:import (java.net URI URL))
  (:import (io.netty.channel Channel ChannelHandler ChannelPipeline))
  (:import (io.netty.handler.ssl SslHandler))

  (:use [cmzlabsclj.nucleus.crypto.ssl :only [MakeSslContext MakeSslClientCtx] ])
  (:use [cmzlabsclj.nucleus.util.core :only [notnil? Try! TryC] ])
  (:use [cmzlabsclj.nucleus.util.str :only [strim nsb hgl?] ]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;(set! *warn-on-reflection* false)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; add SSL
(defn EnableUsrSSL ""

  ^ChannelHandler
  [options]

  (let [ ^SSLContext ctx (MakeSslClientCtx true)
         eg (if (notnil? ctx)
                (doto (.createSSLEngine ctx)
                      (.setUseClientMode true))) ]
    (if (nil? eg) nil (SslHandler. eg))

  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn AddEnableUsrSSL ""

  ^ChannelPipeline
  [pipe options]

  (let [ ssl (= (.getProtocol ^URL (:targetUrl options)) "https") ]
    (when ssl
      (.addLast ^ChannelPipeline pipe "ssl" (EnableUsrSSL options)))
    pipe
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; add SSL
(defn EnableSvrSSL ""

  ^ChannelHandler
  [options]

  (let [ kf (:serverkey options)
         pw (:passwd options)
         ssl (if (nil? kf)
                 nil
                 (MakeSslContext kf pw))
         eg (if (nil? ssl)
                nil
                (doto (.createSSLEngine ssl)
                      (.setUseClientMode false))) ]
    (if (nil? eg) nil (SslHandler. eg))
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(defn AddEnableSvrSSL ""

  ^ChannelPipeline
  [pipe options]

  (let []
    (.addLast ^ChannelPipeline pipe "ssl" (EnableSvrSSL options))
    pipe
  ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
(def ^:private ssl-eof nil)

